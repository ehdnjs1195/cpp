# TMP로 소수를 판별하는 프로그램 만들기

## 문제1. 템플릿 부분 특수화 시에는 반드시 다른 연산자가 붙지 않고, 단순한 식별자만 입력해주어야만 한다.
```
template <>
struct is_prime<2> {
  static const bool result = true;
};

template <>
struct is_prime<3> {
  static const bool result = true;
};

template <int N>
struct is_prime {
  static const bool result = !check_div<N, 2>::result;
};

template <int N, int d>
struct check_div {
  static const bool result = (N % d == 0) || check_div<N, d + 1>::result;
};

template <int N>
struct check_div<N, N / 2> {
  static const bool result = (N % (N / 2) == 0);
};
```
### 해결방법
- N을 타입으로 나타내자. 그렇다면 N/2 역시 직접 계산하는 것이 아니라 타입으로 대체할 수 있고, 그에 따라 템플릿 부분 특수화 문제를 해결할 수 있다.
```
template <int N>
struct INT {
  static const int num = N;
};

template <typename a, typename b>
struct add {
  typedef INT<a::num + b::num> result;
};

template <typename a, typename b>
struct divide {
  typedef INT<a::num / b::num> result;
};

using one = INT<1>;
using two = INT<2>;
using three = INT<3>;
```

## 문제2. 의존 타입에 대하여 타입 명시해주기. 
```
template <typename N, typename d>
struct check_div {
  // result 중에서 한 개라도 true 면 전체가 true
  static const bool result =
    (N::num % d::num == 0) || check_div<N, add<d, one>::result>::result;
};

template <typename N>
struct is_prime {
  static const bool result = !check_div<N, two>::result;
};

template <>
struct is_prime<two> {
  static const bool result = true;
};

template <>
struct is_prime<three> {
  static const bool result = true;
};

template <typename N>
struct check_div<N, divide<N, two>::result> {
  static const bool result = (N::num % (N::num / 2) == 0);
};
```
### 해결방법
- 이때 `check_div<N, add<d, one>::result>::result;` 문장과 `struct check_div<N, divide<N, two>::result>` 문장에서 오류가 발생한다. 
- 이유는 컴파일러가 ::result에 대해 '타입'인지, '값' 인지 잘 모르기 때문이다. 
- 따라서 타입의 자리이므로 typename 키워드를 통해 '얘는 타입이야!' 라고 명시 해주어야 한다.
- 이를 통해 INT<5> 은 값이 아닌 타입으로 컴파일이 잘 되게 된다.